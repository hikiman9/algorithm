n = int(input())

dp = [[0] * 10 for _ in range(n + 1)]

for i in range(1, 10):
    dp[1][i] = 1

for i in range(2, n + 1):
    for j in range(10):
        if j == 0:
            dp[i][j] = dp[i - 1][1]
        elif j == 9:
            dp[i][j] = dp[i - 1][j - 1]
        else:
            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]

print(sum(dp[n]))

# 대충 두어배씩 늘어날 것 같이 생겨서 노가다로 점화식 4항까지 구했는데
# 놀랍게도 규칙을 발견함. 근데 더 놀라운 점은 정답은 5항부터 기존 규칙에서 벗어남
# 처음 생각해낸 답 제출하기 전에 DP에서 뭔가를 통달한 것 마냥
# '오 DP는 이 문제가 DP란 걸 알아내고 노가다로 한 3~4항까지만 구해보면 풀겠구나'
# 라고 생각한 자신이 오만하다는 것을 알게 됨.

# 정답 보고도 이게 뭔 소린가 한참 쳐다봄. 바크통이 따로 없음.
# n자리 수를 2차원 배열로 나타낼 생각은 누가 처음 했는지 싶음
# 이건 그냥 머리 어딘가에 잘 담아뒀다가 비슷한 문제 나오면 써먹던가 해야겠음